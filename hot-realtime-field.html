<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-form/iron-form.html">
<link rel="import" href="../hot-deep-target-behavior/hot-deep-target-behavior.html">

<!--

`<hot-realtime-field>` allows you to:
* Use a custom GET call to check in real time if a field is allowed, depending on what the server returns
* Use a custom PUT call to save that value in real time onto the server

You can have just a GET call, just a PUT call, or both. If you have both, the PUT call will only be called once the GET call's result is all clear.

This element is _extremely_ flexible. What is does is very simple, and it will work out of the box with the default settings. However, it can be configured extensively.

## Saving a value in real time using a PUT, using `put-url`



## Checking a value in real time using a GET, using `get-url` and `get-check`

When specifying `get-url`, your common paper-input element will run the query provided in `get-url` and will expect a JSON response with an array. If `get-check` is `is-empty`, validation will _pass_ if the server returned an empty array (think of it as "pick your username"). If `get-check` is `is-not-empty`, validation will _pass_ if the server returned a non-empty array (think of it as "recover your password").

Example:

<hot-realtime-field get-url="/stores/polymer?name={{name3}}" get-check="is-empty">
<paper-input ID="TOPINPUT" value="{{fieldName3}}" required id="name" name="name" label="Your name"></paper-input>
</hot-realtime-field>

### Extra parameters

You can specify the following attributes:

*  `get-check-message`. Defines the error displayed to the user if `get-check` fails. For example: `User name taken!`. Default: `Error!`

Example:

    <hot-realtime-field get-url="/stores/polymer?name={{name3}}" get-check="is-empty" get-check-message="Username taken!">
      <paper-input ID="TOPINPUT" value="{{fieldName3}}" required id="name" name="name" label="Your name"></paper-input>
    </hot-realtime-field>

* `handle-get-errors`. It's a comma-separated list of error status that will be handled directly. For example, `400,401,403`. Errors that are "handled" will turn the field `invalid`, and will set the `errorMessage` of the field element to the returned error message. Please note that this parameter is mainly here for consistency: its counterpart `handle-put-errors` makes much more sense. If an error isn't handle, an event `user-message-error` is fired, with `detial` set to `{message: "The error message"}`. This will give your application a chance to display the error to the user (otherwise, the error will fall completely silent). Default: `400`

Example:

    <hot-realtime-field get-url="/stores/polymer?name={{name3}}" get-check="is-empty" handleGetErrors="400,401,403">
      <paper-input ID="TOPINPUT" value="{{fieldName3}}" required id="name" name="name" label="Your name"></paper-input>
    </hot-realtime-field>

* `get-default-error-message`.

By default `hot-realtime-field` will try to extrapolate the error message from the response's body (which is expected to be a JSON) using `error-path` (see the next parameter explained). If extrapolation failed (in case the server didn't respond at all, for example), this is the error message that will be shown. Remember that this is only considered in case of HTTP errors. Default: `Error querying`.

* `error-path` The error will be extrapolated from the response's body (which is expected to be a JSON). An example could be { "errors":[ {"field": "name", "error":"The name is too long"} ] }. With the default path,  `errors.0.message`, "The name is too long" will be extrapolated. Default: `errors.0.message`.


## Checking and saving a value in real time using GET + put

## Pre-loading data into the field

### Usage with hot-network

## Using a custom target ID

## Checkbox-type fields

If the field is a checkbox or a radio button, `<hot-immediate>` will toggle it back in case of error, so that the status will be consistent to what's on the server. Also, since checkbox-like buttons often don't provide validation theming,

TODO:

@group Hotplate Elements
@element hot-realtime-field
@demo demo/index.html
-->

<dom-module id="hot-realtime-field">
  <template>
    <style>
      :host {
        display: block;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <iron-ajax id="preloader" on-response="_dataPreloaderResponse"></iron-ajax>
    <iron-ajax id="loader" on-response="_dataLoaderResponse" on-error="_dataLoaderError"></iron-ajax>
    <form is="iron-form" id="hiddenForm" hidden></form>
    <content id="contentNode"></content>
  </template>

  <script>
    Polymer({

      is: 'hot-realtime-field',

      properties: {

        /**
         * If set, then the autocomplete will use the first iron-ajax widget found in the
         * light DOM. this is useful when you want to make a specific query, setting specific
         * headers, etc. The stock iron-ajax will only have URL and METHOD set.
        */
        loaderIronAjaxProvided: {
          type: Boolean
        },

        /**
         * If set, then the autocomplete will use the first iron-ajax widget found in the
         * light DOM. this is useful when you want to make a specific query, setting specific
         * headers, etc. The stock iron-ajax will only have URL and METHOD set.
        */
        preloaderIronAjaxProvided: {
          type: Boolean
        },

        /**
         *
        */
        targetId: {
          type: String
        },

        disableInFlight: {
          type: Boolean
        },

        /**
         *
        */
        preloadUrl: {
          type: String
        },

        /**
         *
        */
        preloadedValuePath: {
          type: String,
          value: "",
        },

        /**
         * If using the internal stock `iron-ajax` object, this will set `iron-ajax`'s url
         * attribute
        */
        getUrl: {
          type: String,
          notify: true,
        },

        /**
         *
        */
        putUrl: {
          type: String,
          notify: true,
        },


        /**
         *
        */
        getCheck: {
          type: String,
          value: "is-empty" // is-empty, is-not-empty, none
        },

        /**
         * Message given in case of error AND no error message is
         * returned by the AJAX call (e.g. timeouts, etc.)
         */
        getCheckMessage: {
          type: String,
          value: "Error!"
        },

        /**
         *
        */
        handlePutErrors: {
          type: String,
          value: "400,422" // Typical errors
        },

        /**
         * Message given in case of error AND no error message is
         * returned by the AJAX call (e.g. timeouts, etc.)
         */
        putDefaultErrorMessage: {
          type: String,
          value: "Error saving!"
        },

        /**
         *
        */
        handleGetErrors: {
          type: String,
          value: "400" // Typical errors
        },

        /**
         * Message given in case of error AND no error message is
         * returned by the AJAX call (e.g. timeouts, etc.)
         */
        getDefaultErrorMessage: {
          type: String,
          value: "Error querying"
        },

        /**
         *
        */
        errorPath: {
          type: String,
          value: 'errors.0.message'
        },

        /**
         * The stock iron-ajax widget used to load data if `ironAjaxProvided` isn't set.
         */
        request: {
          type: Object
        },


        _field: {
          type: Object
        },

      },

       // Q1: Is this a sane approach? The point is to make sure the element works on native
       // elements as well as Polymer ones...
      _listenToField: function(){

        // Start listening for change events from the input field, 4 different cases (!)
        if( this._field.is ){
          this.listen( this._field, this._field.hotAsChecked ? 'checked-changed' : 'value-changed', "_inputReceived");
        } else {
          this.listen( this._field, this._field.hotAsChecked ? 'change' : 'input', "_inputReceived");
        }
      },

      _unlistenToField: function(){

        // Stop listening for change events from the input field, 4 different cases (!)
        if( this._field.is ){
          this.unlisten( this._field, this._field.hotAsChecked ? 'checked-changed' : 'value-changed', "_inputReceived");
        } else {
          this.unlisten( this._field, this._field.hotAsChecked ? 'change' : 'input', "_inputReceived");
        }
      },


      attached: function(){

        // The request object will depend on the iron-ajax-provided attribute.
        // If using a provided iron-ajax element, listeners will be set
        // manually so that responses are caught.
        // Otherwise, the internal request object will be used. The internal one
        // will use hot-autocomplete's `url` and `method` on each request.
        if( this.loaderIronAjaxProvided ){
          this.loaderRequest = this.queryEffectiveChildrenDeep( "iron-ajax#loader", true, 'hot-autocomplete' );
          if( ! this.loaderRequest ) throw( new Error("When using loader-iron-ajax-provided, you must have an iron-ajax with ID 'loader' in your element's DOM"))
          this.listen( this.loaderRequest, "response", '_dataLoaderResponse');
          this.listen( this.loaderRequest, "error", '_dataLoaderError');
        } else {
          // Sets the 'request' attribute
          this.loaderRequest = this.$.loader;
        }

        if( this.preloaderIronAjaxProvided ){
          this.preloaderRequest = this.queryEffectiveChildrenDeep( "iron-ajax#preloader", true, 'hot-autocomplete' );
          if( ! this.preloaderRequest ) throw( new Error("When using preloader-iron-ajax-provided, you must have an iron-ajax with ID 'preloader' in your element's DOM"))
          this.listen( this.preloaderRequest, "response", '_dataPreloaderResponse');
        } else {
          // Sets the 'request' attribute
          this.preloaderRequest = this.$.preloader;

          // This will make pre-loading compatible with hot-network using
          // hot-network's default settings
          this.request = this.preloaderRequest;
        }

        this._listenToField();

        // Needs to be preloaded. Only do this one for each time it's attached.
        if( this.preloadUrl && ! this._preloaded ){
          this._preloaded = true;
          this.preloaderRequest.method = 'get';
          this.preloaderRequest.url = this.preloadUrl;
          this.preloaderRequest.handleAs = 'json';
          this.async( function() { this.preloaderRequest.generateRequest() } );
        }
      },

      detached: function(){

        if( this.loaderIronAjaxProvided ){
          this.unlisten( this.loaderRequest, "response", '_dataLoaderResponse');
          this.unlisten( this.loaderRequest, "error", '_dataLoaderError');
        }

        if( this.preloaderIronAjaxProvided ){
          this.unlisten( this.preloaderRequest, "response", '_dataPreloaderResponse');
        }

        this._unlistenToField();
      },

      _dataPreloaderResponse: function( e ){
        var response = e.detail.response;

        // Insane check to see if this is to be a chekcbox
        var attr = this._field.hotAsChecked ? 'checked' : 'value';
        this._unlistenToField();
        this._field[ attr ] = this.get( this.preloadedValuePath || this._field.name || '', e.detail.response );
        this._listenToField();
      },

      ready: function(){
        if( this.targetId ){
          this._field = this.queryEffectiveChildrenDeep( "#" + this.targetId, true, 'hot-realtime-field' );
        } else {
          this._field = this.getEffectiveChildren()[0];
        }

        // I am only borrowing this method from iron-form. It's the sanest way I found to
        // check whether I am dealing with a text widget or with a switch-like widget
        if( this.$.hiddenForm._usesCheckedInsteadOfValue( this._field ) ) this._field.hotAsChecked = true;
      },

      _inputReceived: function( e ){

        // Won't do anything if the emitter is an unreadied Polymer widgets.This
        // is important as we are listening to events in an element in the light
        // DOM, and we *might* get the initial Polymer setting of the value to ""
        if( this._field.is && !this._field._readied ) return;

        // Set the correct handleAs
        this.loaderRequest.handleAs = 'json';

        // Run the get or the put. NOTE that it's possible that BOTH of them
        // are set. However, in that case `get` will be run first, and `put`
        // will only get run once `get` was successful
        if( this.getUrl ) this._runMethod( 'get' );
        else if( this.putUrl ) this._runMethod( 'put' );
      },

      _runMethod: function( method ){

        if( this.disableInFlight ) this._field.disabled = true;

        this.loaderRequest.method = method;
        this.loaderRequest.url = method == 'get' ? this.getUrl : this.putUrl;
        this.loaderRequest.body = {};
        this.loaderRequest.body[ this._field.getAttribute('name') ] = this._field[ this._field.hotAsChecked ? 'checked' : 'value' ];
        this.loaderRequest.contentType = 'application/json';

        this.async( function(){ this.loaderRequest.generateRequest(); });
      },


      _dataLoaderResponse: function( e ){

        // Only consider the last made request
        if( e.detail != this.loaderRequest.lastRequest ) return;

        if( this.disableInFlight ){
          this._field.disabled = false;
          this._field.focus();
        }

        // Get the response
        var response = e.detail.response;

        // For GET methods, check if the getCheck conditions are satisfied
        if( Polymer.dom( e ).localTarget.method == 'get' && ( this.getCheck == 'is-empty' || this.getChek == 'is-not-empty' ) ){

          var problem = this.getCheck == 'is-empty' ? response.length : !response.length;
          if( Array.isArray( response ) && problem ){
            this._field.errorMessage = this.getCheckMessage;
            this._field.invalid = true;
          } else {
            this._field.invalid = false;
            // The "put" will only happen once the get is successful
            if( this.putUrl ) this._runMethod( 'put' );
          }
        } else {
          this._field.invalid = false;
        }
      },

      _dataLoaderError: function( e ){

        // Only consider the last made request, ignore the rest
        if( e.detail.request != this.loaderRequest.lastRequest ) return;

        if( this.disableInFlight ){
          this._field.disabled = false;
          this._field.focus();
        }

        var method = Polymer.dom( e ).localTarget.method;
        var handleErrors = method == 'put' ? this.handlePutErrors : this.handleGetErrors;

        // Get the response
        var response = e.detail.request.xhr.response;

        // Check if the status is one of the managed ones
        var status = e.detail.request.status;
        var managed = handleErrors.split(',').filter(function( i ){
          return status == i
        })[0]

        // If the status is one of the managed ones, then display the problem "in field"

        var defaultErrorMessage = method == 'put' ? this.putDefaultErrorMessage : this.getDefaultErrorMessage;
        var errorMessage = this.get( this.errorPath, response ) || defaultErrorMessage;
        if( managed ){
          this._field.errorMessage = errorMessage;
          this._field.invalid = true;
        }

        // If it's not "managed", there was an error and YET it didn't work.
        // The element will at least emit an event, so that other widgets can
        // at least explain that there was a problem.
        // Note that checkbox-like widgets rarely display their invalid states
        // nor error messages. So, including them into the club
        if( ! managed || this._field.hotAsChecked ){
          this.fire( 'user-message-error', { message: errorMessage } );
        }

        // If it's a check-like input, it will need to reset it to its previous
        // state for the UI to make sense.
        // Note that it needs to be sandwitched between unlisten/listen or
        // it will attempt to send the state-reverting back to the server...
        if( this._field.hotAsChecked ){
          this._unlistenToField();
          if( this._field.hotAsChecked ) this._field.set( 'checked',  !this._field.checked );
          this._listenToField();
        }

      },

    });
  </script>
</dom-module>
